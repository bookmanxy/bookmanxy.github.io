---
layout: post
title:  "线程知识体系"
categories: java基础
tags:  线程
author: watermelon
---
* content
{:toc}

![线程](https://images.gitee.com/uploads/images/2019/0226/173713_ac5a7442_1210188.jpeg)
## 前言
完善整理java线程篇




# **1、什么叫线程**

## **1.1：操作系统-任务调度**
  大部分操作系统(如Windows、Linux)的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。   
任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来。   
这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发。   

## **1.2：进程**
进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

进程具有的特征：
* 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
* 并发性：任何进程都可以同其他进程一起并发执行；
* 独立性：进程是系统进行资源分配和调度的一个独立单位；
* 结构性：进程由程序、数据和进程控制块三部分组成。


## **1.3：什么叫线程**
线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。

## **1.4：线程与进程**
**从进程到线程 的历史**
* 在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程(Lightweight Process，LWP）。
* 后来，随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念——线程，一般一个进程会有多个(也可是一个)线程。

**两者对比**

* 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位
* 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；
* 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；
* 调度和切换：线程上下文切换比进程上下文切换要快得多。

## **1.5：多核处理器**
对单核处理器来说，同一时间点只有一个任务在执行，多核处理器可支持任务并行处理。
多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。内核线程（Kernel Thread， KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。

现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程

## **1.6：超线程**
超线程技术就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。这种超线程技术(如双核四线程)由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。

程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），轻量级进程就是我们通常意义上所讲的线程(我们在这称它为用户线程)，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。

## **1.7：并发与并行**
并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生
举例子：开车和打电话
小A有两件事要做，开车和打电话。并发安排就是先把车开到路边，打完电话后继续开车（两件事分时间间隔执行）；并行就是边开车边打电话（同一时间做两件事）。

## **1.8：线程的生命周期**
![线程的生命周期](https://images.gitee.com/uploads/images/2019/0228/164457_fdc7c7b6_1210188.png)
### **1.8.1：状态切换**
Thread类中的State枚举有六种值。
NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,ERMINATED;
* NEW 一个被创建的线程，但是还没有调用start方法。操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间；
* RUNNABLE 一个正在被执行的线程的状态，正在占用时间片；
* BLOCKED 一个线程因为等待临界区的锁被阻塞产生的状态（也叫阻塞状态，可能的原因有1：线程通过调用sleep方法进入睡眠状态；  2：线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；3：线程试图得到一个锁，而该锁正被其他线程持有； 4：线程在等待某个触发条件  ）
* WAITING 一个线程进入了锁，但是需要等待其他线程执行某些操作。时间不确定
* TIMED_WAITING 一个线程进入了锁，但是需要等待其他线程执行某些操作。时间确定
* ERMINATED 进程已结束，所以也称结束状态，释放操作系统分配的资源。

生命周期概述
线程的状态转换：
* 当一个线程创建以后，就处于新建状态。那什么时候这个状态会改变呢？只要它调用的start()方法，线程就进入了锁池状态。
* 进入锁池以后就会参与锁的竞争，当它获得锁以后还不能马上运行，因为一个单核CPU在某一时刻，只能执行一个线程，所以他需要操作系统分配给它时间片，才能执行。所以人们通常把一个线程在获得锁后，获得系统时间片之前的状态称之为可运行状态，但Java源代码里面并没有可运行状态这一说。
* 当一个持有对象锁的线程获得CPU时间片以后，开始执行这个线程，此时叫做运行状态。
* 当一个线程正常执行完，那么就进入终止（死亡）状态。系统就会回收这个线程占用的资源。
* 但是，线程的执行并不是那么顺利的。一个正在运行的线程有可能会进入I/O交互，还可能调用sleep()方法，还有可能在当前线程当中有其它线程调用了join()方法。这时候线程就进入了阻塞状态（但这也只是人们在理解的时候意淫加上去的，源代码里也没有定义这一个状态）。阻塞状态的线程是没有释放对象锁的。当I/O交互完成，或sleep()方法完成，或其它调用join()方法的线程执行完毕。阻塞状态的线程就会恢复到可运行状态，此时如果再次获得CPU时间片就会进入运行状态。
一个处于运行状态的线程还可能调用wait()方法、或者带时间参数的wait(long milli)方法。这时候线程就会将对象锁释放，进入等待队列里面（如果是调用wait()方法则进入等待状态，如果是调用带时间参数的则进入定时等待状态）。
一个线程如果的调用了带时间参数的wait(long milli)方法进入了定时等待状态，那么只要时间一到就会进入锁池状态，并不需要notify()或notifyAll()方法来唤醒它。如果调用的是不带时间参数的wait()则需要notify()或notifyAll()这两个方法来唤醒它然后进入锁池状态。进入锁池状态以后继续参与锁的竞争。
* 当一个处于运行状态的线程调用了suspend()方法以后，它就会进入挂起状态（这一方法已经过时不建议使用）。挂起状态的线程也没有释放对象锁，它需要调用resume()方法以后才能恢复到可运行状态。将线程挂起容易导致程序死锁。

### **1.8.2：jvm层面**
 * 摘自：[从jvm层面了解线程的启动和停止](https://mp.weixin.qq.com/s?__biz=MzUxNDA1NDI3OA==&mid=2247484980&idx=3&sn=2826ad9b3481ae18ee311cbcee195ca7&chksm=f94a87ddce3d0ecb988997d6ea64722fe386e749077bdd0712833c899514cbc81a0b63240a5f#rd)
**启动原理**
Java里面创建线程之后必须要调用start方法才能真正的创建一个线程，该方法会调用虚拟机启动一个本地线程，本地线程的创建会调用当前系统创建线程的方法进行创建，并且线程被执行的时候会回调 run方法进行业务逻辑的处理

**停止原理**
线程的终止有主动和被动之分，被动表示线程出现异常退出或者run方法执行完毕，线程会自动终止。主动的方式是 Thread.stop()来实现线程的终止，但是stop()方法是一个过期的方法，官方是不建议使用，理由很简单，stop()方法在中介一个线程时不会保证线程的资源正常释放，也就是不会给线程完成资源释放工作的机会，相当于我们在linux上通过kill -9强制结束一个进程。
使用thread.interrupt()来安全的中断。
```java
public class InterruptedDemo implements Runnable {
    @Override
    public void run() {
        long i = 0l;
        while (!Thread.currentThread().isInterrupted()) {
        //notice here
            i++;
        }
        System.out.println("result:" + i);
    }


    public static void main(String[] args) throws InterruptedException {
        InterruptedDemo interruptedDemo = new InterruptedDemo();
        Thread thread = new Thread(interruptedDemo);
        thread.start();
        Thread.sleep(1000);
        //睡眠一秒
        thread.interrupt();
        //notice here
    }
}
```
Java里面创建线程之后必须要调用start方法才能真正的创建一个线程，该方法会调用虚拟机启动一个本地线程，本地线程的创建会调用当前系统创建线程的方法进行创建，并且线程被执行的时候会回调 run方法进行业务逻辑的处理

thread.interrupt()方法实际就是设置一个interrupted状态标识为true、并且通过ParkEvent的unpark方法来唤醒线程。

**中断异常**
Object.wait、Thread.sleep和Thread.join都会抛出InterruptedException。 
首先，这个异常的意思是表示一个阻塞被其他线程中断了。  
然后，由于线程调用了interrupt()中断方法，那么Object.wait、Thread.sleep等被阻塞的线程被唤醒以后会通过is_interrupted方法判断中断标识的状态变化。线程会不时地检测中断标识位，以判断线程是否应该被中断（中断标识值是否为true）。如果发现中断标识为true，则先清除中断标识，然后抛出InterruptedException
需要注意的是，InterruptedException异常的抛出并不意味着线程必须终止，而是提醒当前线程有中断的操作发生，至于接下来怎么处理取决于线程本身，
比如
* 直接捕获异常不做任何处理
* 将异常往外抛出
* 停止当前线程，并打印异常信息

## **1.9：线程的实现**
**实现方式**
* 继承Thread类实现多线程
* 实现Runnable接口
* 实现Callable接口通过Future包装器来创建Thread线程，这种是带返回值的线程
* 使用线程池ExecutorService

**继承Thread类实现多线程**
继承Thread类，然后重写run方法，在run方法中编写当前线程需要执行的逻辑。最后通过线程实例的start方法来启动一个线程
```java
    public class ThreadDemo extends Thread {
        @Override
        public void run() {
        //重写run方法，提供当前线程执行的逻辑
            System.out.println("Hello world");

        }

        public static void main(String[] args) {
            ThreadDemo threadDemo  = new ThreadDemo();
            threadDemo.start();
        }
    }
    
```
**实现Runnable接口**

如果需要使用线程的类已经继承了其他的类，那么按照Java的单一继承原则，无法再继承Thread类来实现线程，所以可以通过实现Runnable接口来实现多线程
```java
    public class RunnableDemo implements Runnable {
        @Override
        public void run() {
            //重写run方法，提供当前线程执行的逻辑
            System.out.println("Hello world");

        }

        public static void main(String[] args) {
            RunnableDemo runnableDemo = new RunnableDemo();
            new Thread(runnableDemo).start();
        }
    }
```
**实现Callable接口**
在有些多线程使用的场景中，我们有时候需要获取异步线程执行完毕以后的反馈结果，也许是主线程需要拿到子线程的执行结果来处理其他业务逻辑，也许是需要知道线程执行的状态。那么Callable接口可以很好的实现这个功能
```java
    public class CallableDemo implements Callable<String> {
        @Override
        public String call() throws Exception {
            return "hello world";
        }

        public static void main(String[] args) throws ExecutionException, InterruptedException {
            Callable<String> callable = new CallableDemo();
            FutureTask<String> task = new FutureTask<>(callable);
            new Thread(task).start();
            System.out.println(task.get());
            //获取线程的返回值
        }
    }
```
在上面代码案例中的最后一行 task.get()就是获取线程的返回值，这个过程是阻塞的，当子线程还没有执行完的时候，主线程会一直阻塞直到结果返回

**使用线程池**
为了减少频繁创建线程和销毁线程带来的性能开销，在实际使用的时候我们会采用线程池来创建线程。详细的关于线程池的分析下面再陈述。
```java
   public class ExecutorServiceDemo {
        public static void main(String[] args) throws ExecutionException, InterruptedException {
        //创建一个固定线程数的线程池
            ExecutorService pool = Executors.newFixedThreadPool(1);
            Future future = pool.submit(new CallableDemo());
            System.out.println(future.get());
        }
    }
```
pool.submit有几个重载方法，可以传递带返回值的线程实例，也可以传递不带返回值的线程实例，源代码如下
* <T> Future<T> submit(Callable<T> var1);
* <T> Future<T> submit(Runnable var1, T var2);
* Future<?> submit(Runnable var1);

# **2：多线程**
## **2.1：线程安全**
## **2.2：线程组**
* [线程组的使用](https://www.cnblogs.com/xrq730/p/4856072.html)
可以批量管理线程或线程组对象，有效地对线程或线程组对象进行组织。用户创建的所有线程都属于指定线程组，如果没有显示指定属于哪个线
程组，那么该线程就属于默认线程组（即main线程组）。默认情况下，子线程和父线程处于同一个线程组。只有在创建线程时才能指定其所在的线
程组，线程运行中途不能改变它所属的线程组，也就是说线程一旦指定所在的线程组，就直到该线程结束。

## **2.3：线程池**
**线程池到底解决了那些问题**
* 降低资源消耗：通过重用已经创建的线程来降低线程创建和销毁的消耗
* 提高响应速度：任务到达时不需要等待线程创建就可以立即执行
* 提高线程的可管理性：线程池可以统一管理、分配、调优和监控  

**执行流程**
* 调用ThreadPoolExecutor的execute提交线程，首先检查CorePool，如果CorePool内的线程小于CorePoolSize，新创建线程执行任务。
* 如果当前CorePool内的线程大于等于CorePoolSize，那么将线程加入到BlockingQueue。
* 如果不能加入BlockingQueue，在小于MaxPoolSize的情况下创建线程执行任务。
* 如果线程数大于等于MaxPoolSize，那么执行拒绝策略。

## **2.4：线程组和线程池**
* 线程组：线程组存在的意义，首要原因是安全。java默认创建的线程都是属于系统线程组，而同一个线程组的线程是可以相互修改对方的数据的。但如果在不同的线程组中，那么就不能“跨线程组”修改数据，可以从一定程度上保证数据安全。
* 线程池：线程池存在的意义，首要作用是效率。线程的创建和结束都需要耗费一定的系统时间（特别是创建），不停创建和删除线程会浪费大量的时间。所以，在创建出一条线程并使其在执行完任务后不结束，而是使其进入休眠状态，在需要用时再唤醒，那么 就可以节省一定的时间。如果这样的线程比较多，那么就可以使用线程池来进行管理。保证效率。
* 线程组和线程池共有的特点：1,都是管理一定数量的线程2,都可以对线程进行控制---包括休眠，唤醒，结束，创建，中断（暂停）--但并不一定包含全部这些操作。

## **2.5：线程池使用**
* jdk自带
* 阿里jar包
* spring的ioc注入
* springboot如何注入
* tomcat自带线程池

## **2.5.1：jdk自带线程池**
## **2.5.2：阿里jar包池**
## **2.5.3：spring的ioc注入**
## **2.5.4：springboot如何注入**
## **2.5.5：tomcat自带线程池**

## **2.6：线程池配置参数详解**

## **2.7：并发**
## **2.3：资源共享安全**
## **2.4：锁**

# **3：ThreadLocal**

摘自：  
 * [Java中一个线程只有六个状态。至于阻塞、可运行、挂起状态都是人们为了便于理解，自己加上去的。](https://www.cnblogs.com/GooPolaris/p/8079490.html)
 * [线程的应用及挑战](https://mp.weixin.qq.com/s?__biz=MzI0MzI1Mjg5Nw==&mid=2247483676&idx=2&sn=cd62e0076cf3cd2d7c7ea44feab9de15&chksm=e96eaad2de1923c4e17675ad2d6857df34208fcc86b0d905e0710da4399279eef3210bda61ef#rd)
